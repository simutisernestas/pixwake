from abc import abstractmethod
from dataclasses import dataclass, field

import jax.numpy as jnp

from pixwake.core import SimulationContext


class Superposition:
    """Base class for superposition models.

    These models define how to combine ambient and wake-added quantities, such
    as turbulence intensity.
    """

    @abstractmethod
    def __call__(self, ambient: jnp.ndarray, added: jnp.ndarray) -> jnp.ndarray:
        """Combines ambient and added quantities.

        Args:
            ambient: A JAX numpy array of the ambient quantity.
            added: A JAX numpy array of the added quantity from wake effects.

        Returns:
            A JAX numpy array of the effective (combined) quantity.
        """
        raise NotImplementedError


class SqrMaxSum(Superposition):
    """Implements the square-root-of-sum-of-squares superposition.

    This model takes the maximum added contribution from all sources and
    combines it with the ambient value using the formula:
    `sqrt(ambient^2 + max(added)^2)`.
    """

    def __call__(self, ambient: jnp.ndarray, added: jnp.ndarray) -> jnp.ndarray:
        """Combines ambient and added quantities.

        Args:
            ambient: A JAX numpy array of the ambient quantity.
            added: A JAX numpy array of the added quantity from wakes.

        Returns:
            A JAX numpy array of the effective quantity.
        """
        max_added = jnp.max(added, axis=1)
        return jnp.sqrt(ambient**2 + max_added**2)


from pixwake.rotor_avg_models import RotorAvgModel


@dataclass
class WakeTurbulence:
    """Base class for wake-added turbulence models.

    This class provides the framework for models that calculate the additional
    turbulence generated by upstream turbines.

    Attributes:
        superposition: A `Superposition` model to combine ambient and
            wake-added turbulence.
        rotor_avg_model: A `RotorAvgModel` to apply rotor-averaging to the
            wake effects.
    """

    superposition: Superposition = field(default_factory=SqrMaxSum)
    rotor_avg_model: RotorAvgModel | None = None

    def __call__(
        self,
        ws_eff: jnp.ndarray,
        ti_eff: jnp.ndarray | None,
        ctx: SimulationContext,
        wake_radius: jnp.ndarray,
    ) -> jnp.ndarray | None:
        """Calculates the effective turbulence intensity.

        This method computes the added turbulence, applies a wake mask, and then
        uses the specified superposition model to combine it with the ambient
        turbulence.

        If a `rotor_avg_model` is provided, it will be used to average the
        turbulence over the rotor area.

        Args:
            ws_eff: The effective wind speeds at each turbine.
            ti_eff: The effective turbulence intensities at each turbine.
            ctx: The simulation context.
            wake_radius: The radius of the wake from each turbine.

        Returns:
            The effective turbulence intensity at each turbine.
        """
        if self.rotor_avg_model:
            centerline_ctx = SimulationContext(
                turbine=ctx.turbine,
                dw=ctx.dw,
                cw=jnp.zeros_like(ctx.cw),
                ws=ctx.ws,
                ti=ctx.ti,
            )
            centerline_ti_added = self.added_turbulence(ws_eff, ti_eff, centerline_ctx)
            ti_added_m = centerline_ti_added * self.rotor_avg_model.overlapping_area_factor(
                wake_radius, ctx.cw, ctx.turbine.rotor_diameter
            )
        else:
            # Otherwise, calculate added turbulence and apply a simple mask
            ti_added_m = self.added_turbulence(ws_eff, ti_eff, ctx)
            inside_wake = (ctx.dw > 0.0) & (jnp.abs(ctx.cw) < wake_radius)
            ti_added_m = jnp.where(inside_wake, ti_added_m, 0.0)

        # Combine ambient and added turbulence
        ti_ambient = jnp.full(len(ctx.dw), ctx.ti)  # type: ignore
        return self.superposition(ti_ambient, ti_added_m)

    @abstractmethod
    def added_turbulence(
        self,
        ws_eff: jnp.ndarray,
        ti_eff: jnp.ndarray | None,
        ctx: SimulationContext,
    ) -> jnp.ndarray:
        """Calculates the wake-added turbulence intensity.

        This abstract method must be implemented by subclasses to define the
        specific model for calculating added turbulence.

        Args:
            ws_eff: The effective wind speeds at each turbine.
            ti_eff: The effective turbulence intensities at each turbine.
            ctx: The simulation context.

        Returns:
            A JAX numpy array of the added turbulence intensity matrix.
        """
        raise NotImplementedError

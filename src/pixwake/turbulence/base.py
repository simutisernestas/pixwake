from abc import abstractmethod
from dataclasses import dataclass, field

import jax.numpy as jnp

from pixwake.core import SimulationContext


class Superposition:
    """Base class for superposition models.

    These models define how to combine ambient and wake-added quantities, such
    as turbulence intensity.
    """

    @abstractmethod
    def __call__(
        self, ambient: jnp.ndarray, added: jnp.ndarray
    ) -> jnp.ndarray:  # pragma: no cover
        """Combines ambient and added quantities.

        Args:
            ambient: A JAX numpy array of the ambient quantity.
            added: A JAX numpy array of the added quantity from wake effects.

        Returns:
            A JAX numpy array of the effective (combined) quantity.
        """
        raise NotImplementedError


class SqrMaxSum(Superposition):
    """Implements the square-root-of-sum-of-squares superposition.

    This model takes the maximum added contribution from all sources and
    combines it with the ambient value using the formula:
    `sqrt(ambient^2 + max(added)^2)`.
    """

    def __call__(self, ambient: jnp.ndarray, added: jnp.ndarray) -> jnp.ndarray:
        """Combines ambient and added quantities.

        Args:
            ambient: A JAX numpy array of the ambient quantity.
            added: A JAX numpy array of the added quantity from wakes.

        Returns:
            A JAX numpy array of the effective quantity.
        """
        max_added = jnp.max(added, axis=1)
        return jnp.sqrt(ambient**2 + max_added**2)


@dataclass
class WakeTurbulence:
    """Base class for wake-added turbulence models.

    This class provides the framework for models that calculate the additional
    turbulence generated by upstream turbines.

    Attributes:
        superposition: A `Superposition` model to combine ambient and
            wake-added turbulence.
    """

    superposition: Superposition = field(default_factory=SqrMaxSum)

    def __call__(
        self,
        ws_eff: jnp.ndarray,
        ti_eff: jnp.ndarray | None,
        ctx: SimulationContext,
    ) -> jnp.ndarray | None:
        """Calculates the effective turbulence intensity.

        This method computes the added turbulence, applies a wake mask, and then
        uses the specified superposition model to combine it with the ambient
        turbulence.

        Args:
            ws_eff: The effective wind speeds at each turbine.
            ti_eff: The effective turbulence intensities at each turbine.
            ctx: The simulation context.

        Returns:
            The effective turbulence intensity at each turbine.
        """
        assert ctx.wake_radius is not None

        ti_added_m = self._added_turbulence(ws_eff, ti_eff, ctx)
        inside_wake = (ctx.dw > 0.0) & (jnp.abs(ctx.cw) < ctx.wake_radius)
        ti_added_m = jnp.where(inside_wake, ti_added_m, 0.0)

        # Combine ambient and added turbulence
        ti_ambient = jnp.full(len(ctx.dw), ctx.ti)  # type: ignore
        return self.superposition(ti_ambient, ti_added_m)

    @abstractmethod
    def _added_turbulence(
        self,
        ws_eff: jnp.ndarray,
        ti_eff: jnp.ndarray | None,
        ctx: SimulationContext,
    ) -> jnp.ndarray:  # pragma: no cover
        """Calculates the wake-added turbulence intensity.

        This abstract method must be implemented by subclasses to define the
        specific model for calculating added turbulence.

        Args:
            ws_eff: The effective wind speeds at each turbine.
            ti_eff: The effective turbulence intensities at each turbine.
            ctx: The simulation context.

        Returns:
            A JAX numpy array of the added turbulence intensity matrix.
        """
        raise NotImplementedError
